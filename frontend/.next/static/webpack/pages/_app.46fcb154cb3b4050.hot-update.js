"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./components/AuthGuard.jsx":
/*!**********************************!*\
  !*** ./components/AuthGuard.jsx ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ AuthGuard; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/router */ \"./node_modules/next/router.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _contexts_RoleContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/contexts/RoleContext */ \"./contexts/RoleContext.js\");\n\nvar _s = $RefreshSig$();\n\n\n\nconst ROLE_DASHBOARD_MAP = {\n    \"System Admin\": \"/dashboard/admin\",\n    \"Asset Manager\": \"/dashboard/asset-manager\",\n    \"Asset Owner\": \"/dashboard/asset-owner\",\n    \"Custodian\": \"/dashboard/custodian\",\n    \"Inventory Manager\": \"/dashboard/inventory\",\n    \"Procurement Manager\": \"/dashboard/procurement\",\n    \"IT Support\": \"/dashboard/it-support\",\n    \"Audit Officer\": \"/dashboard/audit\",\n    \"Finance\": \"/dashboard/finance\",\n    \"End User\": \"/dashboard/end-user\"\n};\nfunction AuthGuard(param) {\n    let { children } = param;\n    _s();\n    const { isAuthenticated, currentRole, ROLES } = (0,_contexts_RoleContext__WEBPACK_IMPORTED_MODULE_3__.useRole)();\n    const router = (0,next_router__WEBPACK_IMPORTED_MODULE_2__.useRouter)();\n    const [authorized, setAuthorized] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // Wait for initial auth check (RoleContext might need a 'loading' state but relying on initial false + effect works if fast enough, \n        // strictly we should have isAuthChecked state in context but given \"mock\", let's assume if localStorage was there it's loaded)\n        // Actually RoleContext initializes via useEffect, so there is a race condition. \n        // We should delay rendering children until we know auth state is settled. \n        // BUT, since we are doing simple mock, let's just check:\n        // Ideally RoleContext provides `isAuthReady`. \n        // For now, let's assume if it's false, we redirect to login, if it turns true later, we redirect back? \n        // No, that causes flash. \n        // Let's just run this effect on change.\n        const checkAuth = ()=>{\n            const currentPath = router.pathname;\n            const isLoginPage = currentPath === \"/login\";\n            if (!isAuthenticated) {\n                // Not authenticated\n                if (!isLoginPage) {\n                    router.push(\"/login\");\n                } else {\n                    setAuthorized(true);\n                }\n            } else {\n                // Authenticated\n                if (currentPath === \"/\") {\n                    // Redirect root to user's dashboard\n                    const targetPath = ROLE_DASHBOARD_MAP[currentRole.label] || \"/dashboard/end-user\";\n                    router.push(targetPath);\n                } else if (isLoginPage) {\n                    // Allow access to login page even if authenticated (User Request)\n                    setAuthorized(true);\n                } else {\n                    // Check if on a dashboard route, does it match role?\n                    if (currentPath.startsWith(\"/dashboard/\")) {\n                        const expectedPath = ROLE_DASHBOARD_MAP[currentRole.label];\n                        // exact match or just starts with? \"LOCKED DASHBOARDS\" implies specific paths.\n                        // Dashboard paths are distinct. \n                        if (expectedPath && currentPath !== expectedPath) {\n                            // Wrong dashboard for role\n                            router.push(expectedPath);\n                        } else {\n                            setAuthorized(true);\n                        }\n                    } else {\n                        // Allow other pages (like /settings etc if they exist) or redirect?\n                        // User said \"ENTERPRISE dashboard experience for these two roles is FINAL\".\n                        // Assuming other pages are allowed if they are general.\n                        // But for \"Route Protection: ... if role does not match dashboard -> redirect\".\n                        setAuthorized(true);\n                    }\n                }\n            }\n        };\n        // We need a small timeout or check if RoleContext is ready. \n        // Since RoleContext uses useEffect, clear initial \"unauth\" might trigger redirect.\n        // Let's assume RoleContext loads fast from localStorage. \n        // To prevent flash, we could just render nothing until authorized.\n        checkAuth();\n    }, [\n        isAuthenticated,\n        currentRole,\n        router.pathname\n    ]);\n    // Simple loading state to prevent flash of protected content\n    if (!authorized && router.pathname !== \"/login\") {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"min-h-screen flex items-center justify-center bg-slate-950 text-slate-500\",\n            children: \"Loading...\"\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\HP\\\\OneDrive\\\\Desktop\\\\Asset management\\\\asset-management\\\\frontend\\\\components\\\\AuthGuard.jsx\",\n            lineNumber: 88,\n            columnNumber: 16\n        }, this);\n    }\n    return children;\n}\n_s(AuthGuard, \"ppLVKGsc0VG4CpfKyZAkbjrNRpA=\", false, function() {\n    return [\n        _contexts_RoleContext__WEBPACK_IMPORTED_MODULE_3__.useRole,\n        next_router__WEBPACK_IMPORTED_MODULE_2__.useRouter\n    ];\n});\n_c = AuthGuard;\nvar _c;\n$RefreshReg$(_c, \"AuthGuard\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL0F1dGhHdWFyZC5qc3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUE0QztBQUNKO0FBQ1M7QUFFakQsTUFBTUkscUJBQXFCO0lBQ3ZCLGdCQUFnQjtJQUNoQixpQkFBaUI7SUFDakIsZUFBZTtJQUNmLGFBQWE7SUFDYixxQkFBcUI7SUFDckIsdUJBQXVCO0lBQ3ZCLGNBQWM7SUFDZCxpQkFBaUI7SUFDakIsV0FBVztJQUNYLFlBQVk7QUFDaEI7QUFFZSxTQUFTQyxVQUFVLEtBQVk7UUFBWixFQUFFQyxRQUFRLEVBQUUsR0FBWjs7SUFDOUIsTUFBTSxFQUFFQyxlQUFlLEVBQUVDLFdBQVcsRUFBRUMsS0FBSyxFQUFFLEdBQUdOLDhEQUFPQTtJQUN2RCxNQUFNTyxTQUFTUixzREFBU0E7SUFDeEIsTUFBTSxDQUFDUyxZQUFZQyxjQUFjLEdBQUdYLCtDQUFRQSxDQUFDO0lBRTdDRCxnREFBU0EsQ0FBQztRQUNOLHFJQUFxSTtRQUNySSwrSEFBK0g7UUFDL0gsaUZBQWlGO1FBQ2pGLDJFQUEyRTtRQUMzRSx5REFBeUQ7UUFDekQsK0NBQStDO1FBQy9DLHdHQUF3RztRQUN4RywwQkFBMEI7UUFDMUIsd0NBQXdDO1FBRXhDLE1BQU1hLFlBQVk7WUFDZCxNQUFNQyxjQUFjSixPQUFPSyxRQUFRO1lBQ25DLE1BQU1DLGNBQWNGLGdCQUFnQjtZQUVwQyxJQUFJLENBQUNQLGlCQUFpQjtnQkFDbEIsb0JBQW9CO2dCQUNwQixJQUFJLENBQUNTLGFBQWE7b0JBQ2ROLE9BQU9PLElBQUksQ0FBQztnQkFDaEIsT0FBTztvQkFDSEwsY0FBYztnQkFDbEI7WUFDSixPQUFPO2dCQUNILGdCQUFnQjtnQkFDaEIsSUFBSUUsZ0JBQWdCLEtBQUs7b0JBQ3JCLG9DQUFvQztvQkFDcEMsTUFBTUksYUFBYWQsa0JBQWtCLENBQUNJLFlBQVlXLEtBQUssQ0FBQyxJQUFJO29CQUM1RFQsT0FBT08sSUFBSSxDQUFDQztnQkFDaEIsT0FBTyxJQUFJRixhQUFhO29CQUNwQixrRUFBa0U7b0JBQ2xFSixjQUFjO2dCQUNsQixPQUFPO29CQUNILHFEQUFxRDtvQkFDckQsSUFBSUUsWUFBWU0sVUFBVSxDQUFDLGdCQUFnQjt3QkFDdkMsTUFBTUMsZUFBZWpCLGtCQUFrQixDQUFDSSxZQUFZVyxLQUFLLENBQUM7d0JBQzFELCtFQUErRTt3QkFDL0UsaUNBQWlDO3dCQUNqQyxJQUFJRSxnQkFBZ0JQLGdCQUFnQk8sY0FBYzs0QkFDOUMsMkJBQTJCOzRCQUMzQlgsT0FBT08sSUFBSSxDQUFDSTt3QkFDaEIsT0FBTzs0QkFDSFQsY0FBYzt3QkFDbEI7b0JBQ0osT0FBTzt3QkFDSCxvRUFBb0U7d0JBQ3BFLDRFQUE0RTt3QkFDNUUsd0RBQXdEO3dCQUN4RCxnRkFBZ0Y7d0JBQ2hGQSxjQUFjO29CQUNsQjtnQkFDSjtZQUNKO1FBQ0o7UUFFQSw2REFBNkQ7UUFDN0QsbUZBQW1GO1FBQ25GLDBEQUEwRDtRQUMxRCxtRUFBbUU7UUFFbkVDO0lBRUosR0FBRztRQUFDTjtRQUFpQkM7UUFBYUUsT0FBT0ssUUFBUTtLQUFDO0lBRWxELDZEQUE2RDtJQUM3RCxJQUFJLENBQUNKLGNBQWNELE9BQU9LLFFBQVEsS0FBSyxVQUFVO1FBQzdDLHFCQUFPLDhEQUFDTztZQUFJQyxXQUFVO3NCQUE0RTs7Ozs7O0lBQ3RHO0lBRUEsT0FBT2pCO0FBQ1g7R0ExRXdCRDs7UUFDNEJGLDBEQUFPQTtRQUN4Q0Qsa0RBQVNBOzs7S0FGSkciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9BdXRoR3VhcmQuanN4PzY1MmEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgdXNlUm91dGVyIH0gZnJvbSAnbmV4dC9yb3V0ZXInO1xyXG5pbXBvcnQgeyB1c2VSb2xlIH0gZnJvbSAnQC9jb250ZXh0cy9Sb2xlQ29udGV4dCc7XHJcblxyXG5jb25zdCBST0xFX0RBU0hCT0FSRF9NQVAgPSB7XHJcbiAgICAnU3lzdGVtIEFkbWluJzogJy9kYXNoYm9hcmQvYWRtaW4nLFxyXG4gICAgJ0Fzc2V0IE1hbmFnZXInOiAnL2Rhc2hib2FyZC9hc3NldC1tYW5hZ2VyJyxcclxuICAgICdBc3NldCBPd25lcic6ICcvZGFzaGJvYXJkL2Fzc2V0LW93bmVyJyxcclxuICAgICdDdXN0b2RpYW4nOiAnL2Rhc2hib2FyZC9jdXN0b2RpYW4nLFxyXG4gICAgJ0ludmVudG9yeSBNYW5hZ2VyJzogJy9kYXNoYm9hcmQvaW52ZW50b3J5JyxcclxuICAgICdQcm9jdXJlbWVudCBNYW5hZ2VyJzogJy9kYXNoYm9hcmQvcHJvY3VyZW1lbnQnLFxyXG4gICAgJ0lUIFN1cHBvcnQnOiAnL2Rhc2hib2FyZC9pdC1zdXBwb3J0JyxcclxuICAgICdBdWRpdCBPZmZpY2VyJzogJy9kYXNoYm9hcmQvYXVkaXQnLFxyXG4gICAgJ0ZpbmFuY2UnOiAnL2Rhc2hib2FyZC9maW5hbmNlJyxcclxuICAgICdFbmQgVXNlcic6ICcvZGFzaGJvYXJkL2VuZC11c2VyJ1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQXV0aEd1YXJkKHsgY2hpbGRyZW4gfSkge1xyXG4gICAgY29uc3QgeyBpc0F1dGhlbnRpY2F0ZWQsIGN1cnJlbnRSb2xlLCBST0xFUyB9ID0gdXNlUm9sZSgpO1xyXG4gICAgY29uc3Qgcm91dGVyID0gdXNlUm91dGVyKCk7XHJcbiAgICBjb25zdCBbYXV0aG9yaXplZCwgc2V0QXV0aG9yaXplZF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAvLyBXYWl0IGZvciBpbml0aWFsIGF1dGggY2hlY2sgKFJvbGVDb250ZXh0IG1pZ2h0IG5lZWQgYSAnbG9hZGluZycgc3RhdGUgYnV0IHJlbHlpbmcgb24gaW5pdGlhbCBmYWxzZSArIGVmZmVjdCB3b3JrcyBpZiBmYXN0IGVub3VnaCwgXHJcbiAgICAgICAgLy8gc3RyaWN0bHkgd2Ugc2hvdWxkIGhhdmUgaXNBdXRoQ2hlY2tlZCBzdGF0ZSBpbiBjb250ZXh0IGJ1dCBnaXZlbiBcIm1vY2tcIiwgbGV0J3MgYXNzdW1lIGlmIGxvY2FsU3RvcmFnZSB3YXMgdGhlcmUgaXQncyBsb2FkZWQpXHJcbiAgICAgICAgLy8gQWN0dWFsbHkgUm9sZUNvbnRleHQgaW5pdGlhbGl6ZXMgdmlhIHVzZUVmZmVjdCwgc28gdGhlcmUgaXMgYSByYWNlIGNvbmRpdGlvbi4gXHJcbiAgICAgICAgLy8gV2Ugc2hvdWxkIGRlbGF5IHJlbmRlcmluZyBjaGlsZHJlbiB1bnRpbCB3ZSBrbm93IGF1dGggc3RhdGUgaXMgc2V0dGxlZC4gXHJcbiAgICAgICAgLy8gQlVULCBzaW5jZSB3ZSBhcmUgZG9pbmcgc2ltcGxlIG1vY2ssIGxldCdzIGp1c3QgY2hlY2s6XHJcbiAgICAgICAgLy8gSWRlYWxseSBSb2xlQ29udGV4dCBwcm92aWRlcyBgaXNBdXRoUmVhZHlgLiBcclxuICAgICAgICAvLyBGb3Igbm93LCBsZXQncyBhc3N1bWUgaWYgaXQncyBmYWxzZSwgd2UgcmVkaXJlY3QgdG8gbG9naW4sIGlmIGl0IHR1cm5zIHRydWUgbGF0ZXIsIHdlIHJlZGlyZWN0IGJhY2s/IFxyXG4gICAgICAgIC8vIE5vLCB0aGF0IGNhdXNlcyBmbGFzaC4gXHJcbiAgICAgICAgLy8gTGV0J3MganVzdCBydW4gdGhpcyBlZmZlY3Qgb24gY2hhbmdlLlxyXG5cclxuICAgICAgICBjb25zdCBjaGVja0F1dGggPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQYXRoID0gcm91dGVyLnBhdGhuYW1lO1xyXG4gICAgICAgICAgICBjb25zdCBpc0xvZ2luUGFnZSA9IGN1cnJlbnRQYXRoID09PSAnL2xvZ2luJztcclxuXHJcbiAgICAgICAgICAgIGlmICghaXNBdXRoZW50aWNhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBOb3QgYXV0aGVudGljYXRlZFxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0xvZ2luUGFnZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlci5wdXNoKCcvbG9naW4nKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0QXV0aG9yaXplZCh0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIEF1dGhlbnRpY2F0ZWRcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UGF0aCA9PT0gJy8nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVkaXJlY3Qgcm9vdCB0byB1c2VyJ3MgZGFzaGJvYXJkXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0UGF0aCA9IFJPTEVfREFTSEJPQVJEX01BUFtjdXJyZW50Um9sZS5sYWJlbF0gfHwgJy9kYXNoYm9hcmQvZW5kLXVzZXInO1xyXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlci5wdXNoKHRhcmdldFBhdGgpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc0xvZ2luUGFnZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IGFjY2VzcyB0byBsb2dpbiBwYWdlIGV2ZW4gaWYgYXV0aGVudGljYXRlZCAoVXNlciBSZXF1ZXN0KVxyXG4gICAgICAgICAgICAgICAgICAgIHNldEF1dGhvcml6ZWQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIG9uIGEgZGFzaGJvYXJkIHJvdXRlLCBkb2VzIGl0IG1hdGNoIHJvbGU/XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQYXRoLnN0YXJ0c1dpdGgoJy9kYXNoYm9hcmQvJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRQYXRoID0gUk9MRV9EQVNIQk9BUkRfTUFQW2N1cnJlbnRSb2xlLmxhYmVsXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXhhY3QgbWF0Y2ggb3IganVzdCBzdGFydHMgd2l0aD8gXCJMT0NLRUQgREFTSEJPQVJEU1wiIGltcGxpZXMgc3BlY2lmaWMgcGF0aHMuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERhc2hib2FyZCBwYXRocyBhcmUgZGlzdGluY3QuIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwZWN0ZWRQYXRoICYmIGN1cnJlbnRQYXRoICE9PSBleHBlY3RlZFBhdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdyb25nIGRhc2hib2FyZCBmb3Igcm9sZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVyLnB1c2goZXhwZWN0ZWRQYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEF1dGhvcml6ZWQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGxvdyBvdGhlciBwYWdlcyAobGlrZSAvc2V0dGluZ3MgZXRjIGlmIHRoZXkgZXhpc3QpIG9yIHJlZGlyZWN0P1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2VyIHNhaWQgXCJFTlRFUlBSSVNFIGRhc2hib2FyZCBleHBlcmllbmNlIGZvciB0aGVzZSB0d28gcm9sZXMgaXMgRklOQUxcIi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXNzdW1pbmcgb3RoZXIgcGFnZXMgYXJlIGFsbG93ZWQgaWYgdGhleSBhcmUgZ2VuZXJhbC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQnV0IGZvciBcIlJvdXRlIFByb3RlY3Rpb246IC4uLiBpZiByb2xlIGRvZXMgbm90IG1hdGNoIGRhc2hib2FyZCAtPiByZWRpcmVjdFwiLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRBdXRob3JpemVkKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIFdlIG5lZWQgYSBzbWFsbCB0aW1lb3V0IG9yIGNoZWNrIGlmIFJvbGVDb250ZXh0IGlzIHJlYWR5LiBcclxuICAgICAgICAvLyBTaW5jZSBSb2xlQ29udGV4dCB1c2VzIHVzZUVmZmVjdCwgY2xlYXIgaW5pdGlhbCBcInVuYXV0aFwiIG1pZ2h0IHRyaWdnZXIgcmVkaXJlY3QuXHJcbiAgICAgICAgLy8gTGV0J3MgYXNzdW1lIFJvbGVDb250ZXh0IGxvYWRzIGZhc3QgZnJvbSBsb2NhbFN0b3JhZ2UuIFxyXG4gICAgICAgIC8vIFRvIHByZXZlbnQgZmxhc2gsIHdlIGNvdWxkIGp1c3QgcmVuZGVyIG5vdGhpbmcgdW50aWwgYXV0aG9yaXplZC5cclxuXHJcbiAgICAgICAgY2hlY2tBdXRoKCk7XHJcblxyXG4gICAgfSwgW2lzQXV0aGVudGljYXRlZCwgY3VycmVudFJvbGUsIHJvdXRlci5wYXRobmFtZV0pO1xyXG5cclxuICAgIC8vIFNpbXBsZSBsb2FkaW5nIHN0YXRlIHRvIHByZXZlbnQgZmxhc2ggb2YgcHJvdGVjdGVkIGNvbnRlbnRcclxuICAgIGlmICghYXV0aG9yaXplZCAmJiByb3V0ZXIucGF0aG5hbWUgIT09ICcvbG9naW4nKSB7XHJcbiAgICAgICAgcmV0dXJuIDxkaXYgY2xhc3NOYW1lPVwibWluLWgtc2NyZWVuIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIGJnLXNsYXRlLTk1MCB0ZXh0LXNsYXRlLTUwMFwiPkxvYWRpbmcuLi48L2Rpdj47XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNoaWxkcmVuO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsInVzZVJvdXRlciIsInVzZVJvbGUiLCJST0xFX0RBU0hCT0FSRF9NQVAiLCJBdXRoR3VhcmQiLCJjaGlsZHJlbiIsImlzQXV0aGVudGljYXRlZCIsImN1cnJlbnRSb2xlIiwiUk9MRVMiLCJyb3V0ZXIiLCJhdXRob3JpemVkIiwic2V0QXV0aG9yaXplZCIsImNoZWNrQXV0aCIsImN1cnJlbnRQYXRoIiwicGF0aG5hbWUiLCJpc0xvZ2luUGFnZSIsInB1c2giLCJ0YXJnZXRQYXRoIiwibGFiZWwiLCJzdGFydHNXaXRoIiwiZXhwZWN0ZWRQYXRoIiwiZGl2IiwiY2xhc3NOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/AuthGuard.jsx\n"));

/***/ })

});