"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./components/AuthGuard.jsx":
/*!**********************************!*\
  !*** ./components/AuthGuard.jsx ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ AuthGuard; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/router */ \"./node_modules/next/router.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _contexts_RoleContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/contexts/RoleContext */ \"./contexts/RoleContext.js\");\n\nvar _s = $RefreshSig$();\n\n\n\nconst ROLE_DASHBOARD_MAP = {\n    \"System Admin\": \"/dashboard/system-admin\",\n    \"Asset & Inventory Manager\": \"/dashboard/asset-inventory-manager\",\n    \"Procurement & Finance\": \"/dashboard/procurement-finance\",\n    \"IT Management\": \"/dashboard/it-management\",\n    \"End User\": \"/dashboard/end-user\"\n};\nfunction AuthGuard(param) {\n    let { children } = param;\n    _s();\n    const { isAuthenticated, currentRole, ROLES } = (0,_contexts_RoleContext__WEBPACK_IMPORTED_MODULE_3__.useRole)();\n    const router = (0,next_router__WEBPACK_IMPORTED_MODULE_2__.useRouter)();\n    const [authorized, setAuthorized] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // Wait for initial auth check (RoleContext might need a 'loading' state but relying on initial false + effect works if fast enough, \n        // strictly we should have isAuthChecked state in context but given \"mock\", let's assume if localStorage was there it's loaded)\n        // Actually RoleContext initializes via useEffect, so there is a race condition. \n        // We should delay rendering children until we know auth state is settled. \n        // BUT, since we are doing simple mock, let's just check:\n        // Ideally RoleContext provides `isAuthReady`. \n        // For now, let's assume if it's false, we redirect to login, if it turns true later, we redirect back? \n        // No, that causes flash. \n        // Let's just run this effect on change.\n        const checkAuth = ()=>{\n            const currentPath = router.pathname;\n            const isLoginPage = currentPath === \"/login\";\n            if (!isAuthenticated) {\n                // Not authenticated\n                if (!isLoginPage) {\n                    router.push(\"/login\");\n                } else {\n                    setAuthorized(true);\n                }\n            } else {\n                // Authenticated\n                if (currentPath === \"/\") {\n                    // Redirect root to user's dashboard\n                    const targetPath = ROLE_DASHBOARD_MAP[currentRole.label] || \"/dashboard/end-user\";\n                    router.push(targetPath);\n                } else if (isLoginPage) {\n                    // Allow access to login page even if authenticated (User Request)\n                    setAuthorized(true);\n                } else {\n                    // Check if on a dashboard route, does it match role?\n                    if (currentPath.startsWith(\"/dashboard/\")) {\n                        const expectedPath = ROLE_DASHBOARD_MAP[currentRole.label];\n                        // exact match or just starts with? \"LOCKED DASHBOARDS\" implies specific paths.\n                        // Dashboard paths are distinct. \n                        if (expectedPath && currentPath !== expectedPath) {\n                            // Wrong dashboard for role\n                            router.push(expectedPath);\n                        } else {\n                            setAuthorized(true);\n                        }\n                    } else {\n                        // Allow other pages (like /settings etc if they exist) or redirect?\n                        // User said \"ENTERPRISE dashboard experience for these two roles is FINAL\".\n                        // Assuming other pages are allowed if they are general.\n                        // But for \"Route Protection: ... if role does not match dashboard -> redirect\".\n                        setAuthorized(true);\n                    }\n                }\n            }\n        };\n        // We need a small timeout or check if RoleContext is ready. \n        // Since RoleContext uses useEffect, clear initial \"unauth\" might trigger redirect.\n        // Let's assume RoleContext loads fast from localStorage. \n        // To prevent flash, we could just render nothing until authorized.\n        checkAuth();\n    }, [\n        isAuthenticated,\n        currentRole,\n        router.pathname\n    ]);\n    // Simple loading state to prevent flash of protected content\n    if (!authorized && router.pathname !== \"/login\") {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"min-h-screen flex items-center justify-center bg-slate-950 text-slate-500\",\n            children: \"Loading...\"\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\HP\\\\OneDrive\\\\Desktop\\\\Asset management\\\\asset-management\\\\frontend\\\\components\\\\AuthGuard.jsx\",\n            lineNumber: 83,\n            columnNumber: 16\n        }, this);\n    }\n    return children;\n}\n_s(AuthGuard, \"ppLVKGsc0VG4CpfKyZAkbjrNRpA=\", false, function() {\n    return [\n        _contexts_RoleContext__WEBPACK_IMPORTED_MODULE_3__.useRole,\n        next_router__WEBPACK_IMPORTED_MODULE_2__.useRouter\n    ];\n});\n_c = AuthGuard;\nvar _c;\n$RefreshReg$(_c, \"AuthGuard\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL0F1dGhHdWFyZC5qc3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUE0QztBQUNKO0FBQ1M7QUFFakQsTUFBTUkscUJBQXFCO0lBQ3ZCLGdCQUFnQjtJQUNoQiw2QkFBNkI7SUFDN0IseUJBQXlCO0lBQ3pCLGlCQUFpQjtJQUNqQixZQUFZO0FBQ2hCO0FBRWUsU0FBU0MsVUFBVSxLQUFZO1FBQVosRUFBRUMsUUFBUSxFQUFFLEdBQVo7O0lBQzlCLE1BQU0sRUFBRUMsZUFBZSxFQUFFQyxXQUFXLEVBQUVDLEtBQUssRUFBRSxHQUFHTiw4REFBT0E7SUFDdkQsTUFBTU8sU0FBU1Isc0RBQVNBO0lBQ3hCLE1BQU0sQ0FBQ1MsWUFBWUMsY0FBYyxHQUFHWCwrQ0FBUUEsQ0FBQztJQUU3Q0QsZ0RBQVNBLENBQUM7UUFDTixxSUFBcUk7UUFDckksK0hBQStIO1FBQy9ILGlGQUFpRjtRQUNqRiwyRUFBMkU7UUFDM0UseURBQXlEO1FBQ3pELCtDQUErQztRQUMvQyx3R0FBd0c7UUFDeEcsMEJBQTBCO1FBQzFCLHdDQUF3QztRQUV4QyxNQUFNYSxZQUFZO1lBQ2QsTUFBTUMsY0FBY0osT0FBT0ssUUFBUTtZQUNuQyxNQUFNQyxjQUFjRixnQkFBZ0I7WUFFcEMsSUFBSSxDQUFDUCxpQkFBaUI7Z0JBQ2xCLG9CQUFvQjtnQkFDcEIsSUFBSSxDQUFDUyxhQUFhO29CQUNkTixPQUFPTyxJQUFJLENBQUM7Z0JBQ2hCLE9BQU87b0JBQ0hMLGNBQWM7Z0JBQ2xCO1lBQ0osT0FBTztnQkFDSCxnQkFBZ0I7Z0JBQ2hCLElBQUlFLGdCQUFnQixLQUFLO29CQUNyQixvQ0FBb0M7b0JBQ3BDLE1BQU1JLGFBQWFkLGtCQUFrQixDQUFDSSxZQUFZVyxLQUFLLENBQUMsSUFBSTtvQkFDNURULE9BQU9PLElBQUksQ0FBQ0M7Z0JBQ2hCLE9BQU8sSUFBSUYsYUFBYTtvQkFDcEIsa0VBQWtFO29CQUNsRUosY0FBYztnQkFDbEIsT0FBTztvQkFDSCxxREFBcUQ7b0JBQ3JELElBQUlFLFlBQVlNLFVBQVUsQ0FBQyxnQkFBZ0I7d0JBQ3ZDLE1BQU1DLGVBQWVqQixrQkFBa0IsQ0FBQ0ksWUFBWVcsS0FBSyxDQUFDO3dCQUMxRCwrRUFBK0U7d0JBQy9FLGlDQUFpQzt3QkFDakMsSUFBSUUsZ0JBQWdCUCxnQkFBZ0JPLGNBQWM7NEJBQzlDLDJCQUEyQjs0QkFDM0JYLE9BQU9PLElBQUksQ0FBQ0k7d0JBQ2hCLE9BQU87NEJBQ0hULGNBQWM7d0JBQ2xCO29CQUNKLE9BQU87d0JBQ0gsb0VBQW9FO3dCQUNwRSw0RUFBNEU7d0JBQzVFLHdEQUF3RDt3QkFDeEQsZ0ZBQWdGO3dCQUNoRkEsY0FBYztvQkFDbEI7Z0JBQ0o7WUFDSjtRQUNKO1FBRUEsNkRBQTZEO1FBQzdELG1GQUFtRjtRQUNuRiwwREFBMEQ7UUFDMUQsbUVBQW1FO1FBRW5FQztJQUVKLEdBQUc7UUFBQ047UUFBaUJDO1FBQWFFLE9BQU9LLFFBQVE7S0FBQztJQUVsRCw2REFBNkQ7SUFDN0QsSUFBSSxDQUFDSixjQUFjRCxPQUFPSyxRQUFRLEtBQUssVUFBVTtRQUM3QyxxQkFBTyw4REFBQ087WUFBSUMsV0FBVTtzQkFBNEU7Ozs7OztJQUN0RztJQUVBLE9BQU9qQjtBQUNYO0dBMUV3QkQ7O1FBQzRCRiwwREFBT0E7UUFDeENELGtEQUFTQTs7O0tBRkpHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvQXV0aEd1YXJkLmpzeD82NTJhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gJ25leHQvcm91dGVyJztcclxuaW1wb3J0IHsgdXNlUm9sZSB9IGZyb20gJ0AvY29udGV4dHMvUm9sZUNvbnRleHQnO1xyXG5cclxuY29uc3QgUk9MRV9EQVNIQk9BUkRfTUFQID0ge1xyXG4gICAgJ1N5c3RlbSBBZG1pbic6ICcvZGFzaGJvYXJkL3N5c3RlbS1hZG1pbicsXHJcbiAgICAnQXNzZXQgJiBJbnZlbnRvcnkgTWFuYWdlcic6ICcvZGFzaGJvYXJkL2Fzc2V0LWludmVudG9yeS1tYW5hZ2VyJyxcclxuICAgICdQcm9jdXJlbWVudCAmIEZpbmFuY2UnOiAnL2Rhc2hib2FyZC9wcm9jdXJlbWVudC1maW5hbmNlJyxcclxuICAgICdJVCBNYW5hZ2VtZW50JzogJy9kYXNoYm9hcmQvaXQtbWFuYWdlbWVudCcsXHJcbiAgICAnRW5kIFVzZXInOiAnL2Rhc2hib2FyZC9lbmQtdXNlcidcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEF1dGhHdWFyZCh7IGNoaWxkcmVuIH0pIHtcclxuICAgIGNvbnN0IHsgaXNBdXRoZW50aWNhdGVkLCBjdXJyZW50Um9sZSwgUk9MRVMgfSA9IHVzZVJvbGUoKTtcclxuICAgIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpO1xyXG4gICAgY29uc3QgW2F1dGhvcml6ZWQsIHNldEF1dGhvcml6ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgLy8gV2FpdCBmb3IgaW5pdGlhbCBhdXRoIGNoZWNrIChSb2xlQ29udGV4dCBtaWdodCBuZWVkIGEgJ2xvYWRpbmcnIHN0YXRlIGJ1dCByZWx5aW5nIG9uIGluaXRpYWwgZmFsc2UgKyBlZmZlY3Qgd29ya3MgaWYgZmFzdCBlbm91Z2gsIFxyXG4gICAgICAgIC8vIHN0cmljdGx5IHdlIHNob3VsZCBoYXZlIGlzQXV0aENoZWNrZWQgc3RhdGUgaW4gY29udGV4dCBidXQgZ2l2ZW4gXCJtb2NrXCIsIGxldCdzIGFzc3VtZSBpZiBsb2NhbFN0b3JhZ2Ugd2FzIHRoZXJlIGl0J3MgbG9hZGVkKVxyXG4gICAgICAgIC8vIEFjdHVhbGx5IFJvbGVDb250ZXh0IGluaXRpYWxpemVzIHZpYSB1c2VFZmZlY3QsIHNvIHRoZXJlIGlzIGEgcmFjZSBjb25kaXRpb24uIFxyXG4gICAgICAgIC8vIFdlIHNob3VsZCBkZWxheSByZW5kZXJpbmcgY2hpbGRyZW4gdW50aWwgd2Uga25vdyBhdXRoIHN0YXRlIGlzIHNldHRsZWQuIFxyXG4gICAgICAgIC8vIEJVVCwgc2luY2Ugd2UgYXJlIGRvaW5nIHNpbXBsZSBtb2NrLCBsZXQncyBqdXN0IGNoZWNrOlxyXG4gICAgICAgIC8vIElkZWFsbHkgUm9sZUNvbnRleHQgcHJvdmlkZXMgYGlzQXV0aFJlYWR5YC4gXHJcbiAgICAgICAgLy8gRm9yIG5vdywgbGV0J3MgYXNzdW1lIGlmIGl0J3MgZmFsc2UsIHdlIHJlZGlyZWN0IHRvIGxvZ2luLCBpZiBpdCB0dXJucyB0cnVlIGxhdGVyLCB3ZSByZWRpcmVjdCBiYWNrPyBcclxuICAgICAgICAvLyBObywgdGhhdCBjYXVzZXMgZmxhc2guIFxyXG4gICAgICAgIC8vIExldCdzIGp1c3QgcnVuIHRoaXMgZWZmZWN0IG9uIGNoYW5nZS5cclxuXHJcbiAgICAgICAgY29uc3QgY2hlY2tBdXRoID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50UGF0aCA9IHJvdXRlci5wYXRobmFtZTtcclxuICAgICAgICAgICAgY29uc3QgaXNMb2dpblBhZ2UgPSBjdXJyZW50UGF0aCA9PT0gJy9sb2dpbic7XHJcblxyXG4gICAgICAgICAgICBpZiAoIWlzQXV0aGVudGljYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gTm90IGF1dGhlbnRpY2F0ZWRcclxuICAgICAgICAgICAgICAgIGlmICghaXNMb2dpblBhZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICByb3V0ZXIucHVzaCgnL2xvZ2luJyk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldEF1dGhvcml6ZWQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBdXRoZW50aWNhdGVkXHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFBhdGggPT09ICcvJykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlZGlyZWN0IHJvb3QgdG8gdXNlcidzIGRhc2hib2FyZFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldFBhdGggPSBST0xFX0RBU0hCT0FSRF9NQVBbY3VycmVudFJvbGUubGFiZWxdIHx8ICcvZGFzaGJvYXJkL2VuZC11c2VyJztcclxuICAgICAgICAgICAgICAgICAgICByb3V0ZXIucHVzaCh0YXJnZXRQYXRoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNMb2dpblBhZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBBbGxvdyBhY2Nlc3MgdG8gbG9naW4gcGFnZSBldmVuIGlmIGF1dGhlbnRpY2F0ZWQgKFVzZXIgUmVxdWVzdClcclxuICAgICAgICAgICAgICAgICAgICBzZXRBdXRob3JpemVkKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBvbiBhIGRhc2hib2FyZCByb3V0ZSwgZG9lcyBpdCBtYXRjaCByb2xlP1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UGF0aC5zdGFydHNXaXRoKCcvZGFzaGJvYXJkLycpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkUGF0aCA9IFJPTEVfREFTSEJPQVJEX01BUFtjdXJyZW50Um9sZS5sYWJlbF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4YWN0IG1hdGNoIG9yIGp1c3Qgc3RhcnRzIHdpdGg/IFwiTE9DS0VEIERBU0hCT0FSRFNcIiBpbXBsaWVzIHNwZWNpZmljIHBhdGhzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEYXNoYm9hcmQgcGF0aHMgYXJlIGRpc3RpbmN0LiBcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cGVjdGVkUGF0aCAmJiBjdXJyZW50UGF0aCAhPT0gZXhwZWN0ZWRQYXRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXcm9uZyBkYXNoYm9hcmQgZm9yIHJvbGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlci5wdXNoKGV4cGVjdGVkUGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRBdXRob3JpemVkKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsb3cgb3RoZXIgcGFnZXMgKGxpa2UgL3NldHRpbmdzIGV0YyBpZiB0aGV5IGV4aXN0KSBvciByZWRpcmVjdD9cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlciBzYWlkIFwiRU5URVJQUklTRSBkYXNoYm9hcmQgZXhwZXJpZW5jZSBmb3IgdGhlc2UgdHdvIHJvbGVzIGlzIEZJTkFMXCIuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFzc3VtaW5nIG90aGVyIHBhZ2VzIGFyZSBhbGxvd2VkIGlmIHRoZXkgYXJlIGdlbmVyYWwuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJ1dCBmb3IgXCJSb3V0ZSBQcm90ZWN0aW9uOiAuLi4gaWYgcm9sZSBkb2VzIG5vdCBtYXRjaCBkYXNoYm9hcmQgLT4gcmVkaXJlY3RcIi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0QXV0aG9yaXplZCh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBXZSBuZWVkIGEgc21hbGwgdGltZW91dCBvciBjaGVjayBpZiBSb2xlQ29udGV4dCBpcyByZWFkeS4gXHJcbiAgICAgICAgLy8gU2luY2UgUm9sZUNvbnRleHQgdXNlcyB1c2VFZmZlY3QsIGNsZWFyIGluaXRpYWwgXCJ1bmF1dGhcIiBtaWdodCB0cmlnZ2VyIHJlZGlyZWN0LlxyXG4gICAgICAgIC8vIExldCdzIGFzc3VtZSBSb2xlQ29udGV4dCBsb2FkcyBmYXN0IGZyb20gbG9jYWxTdG9yYWdlLiBcclxuICAgICAgICAvLyBUbyBwcmV2ZW50IGZsYXNoLCB3ZSBjb3VsZCBqdXN0IHJlbmRlciBub3RoaW5nIHVudGlsIGF1dGhvcml6ZWQuXHJcblxyXG4gICAgICAgIGNoZWNrQXV0aCgpO1xyXG5cclxuICAgIH0sIFtpc0F1dGhlbnRpY2F0ZWQsIGN1cnJlbnRSb2xlLCByb3V0ZXIucGF0aG5hbWVdKTtcclxuXHJcbiAgICAvLyBTaW1wbGUgbG9hZGluZyBzdGF0ZSB0byBwcmV2ZW50IGZsYXNoIG9mIHByb3RlY3RlZCBjb250ZW50XHJcbiAgICBpZiAoIWF1dGhvcml6ZWQgJiYgcm91dGVyLnBhdGhuYW1lICE9PSAnL2xvZ2luJykge1xyXG4gICAgICAgIHJldHVybiA8ZGl2IGNsYXNzTmFtZT1cIm1pbi1oLXNjcmVlbiBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBiZy1zbGF0ZS05NTAgdGV4dC1zbGF0ZS01MDBcIj5Mb2FkaW5nLi4uPC9kaXY+O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjaGlsZHJlbjtcclxufVxyXG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJ1c2VSb3V0ZXIiLCJ1c2VSb2xlIiwiUk9MRV9EQVNIQk9BUkRfTUFQIiwiQXV0aEd1YXJkIiwiY2hpbGRyZW4iLCJpc0F1dGhlbnRpY2F0ZWQiLCJjdXJyZW50Um9sZSIsIlJPTEVTIiwicm91dGVyIiwiYXV0aG9yaXplZCIsInNldEF1dGhvcml6ZWQiLCJjaGVja0F1dGgiLCJjdXJyZW50UGF0aCIsInBhdGhuYW1lIiwiaXNMb2dpblBhZ2UiLCJwdXNoIiwidGFyZ2V0UGF0aCIsImxhYmVsIiwic3RhcnRzV2l0aCIsImV4cGVjdGVkUGF0aCIsImRpdiIsImNsYXNzTmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/AuthGuard.jsx\n"));

/***/ })

});